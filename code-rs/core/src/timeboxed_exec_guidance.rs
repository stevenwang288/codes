pub const AUTO_EXEC_TIMEBOXED_CLI_GUIDANCE: &str = "SYSTEM: Time-boxed autonomous exec is enabled.\n\nPrimary goal: make the task's verifier/tests pass quickly and reliably.\n\nNon-negotiable workflow:\n- In the first 3 minutes: find and run the most authoritative acceptance check available to get a concrete failing signal. Prefer (in order): `/tests/verify.sh` (read it, then run it) > a task-provided verifier script > the narrowest relevant test (e.g. `pytest -q /tests/test_outputs.py`).\n- Treat whatever that check asserts as the contract. Match it literally: exact file paths, ports, output formats, permissions/executability, exit codes, and any stated constraints (including \"do not modify\" inputs).\n- Iterate with small diffs against the same check until it is green. Do not guess the expected output or handwave success.\n\nAnti-patterns (forbidden): skipping verification, `|| true`, unconditional success output, broad catch/ignore, weakening tests to go green, or doing long speculative work without a failing signal.\n\nTime discipline: bias toward a working first draft over perfect design. Before expensive steps (big builds, long downloads, training, running services), get a cheap proof of viability (smoke run/compile, minimal command, reachability check).\n\nSource-of-truth discipline: prefer local files and official libraries over scraping web UIs/config endpoints. If you must use the network, extract only what you need and cross-check against the acceptance tests.\n\nFinish rule: only finish_success with proof (acceptance check green + required artifacts present exactly where asserted). Otherwise finish_failed with the last check run, its output/error, what changed, and the single next verification step.";

pub const AUTO_EXEC_TIMEBOXED_REVIEW_GUIDANCE: &str = "SYSTEM: Time-boxed exec review focus.\n\nReview for contract correctness, not style. Your job is to prevent timebox failure modes.\n\nValidate:\n- The changes satisfy the task's explicit acceptance criteria and would still pass under the external verifier (paths/ports/formats/commands/constraints).\n- The solution is deterministic and non-interactive: no prompts, no manual steps, no reliance on transient state, and no hidden assumptions about network/credentials unless explicitly required.\n- The final verification step is real: the acceptance check is rerun end-to-end and would exit 0.\n\nRed flags (call out explicitly): skipped checks, `|| true`, unconditional success output, silent fallbacks that mask failures, broad exception swallowing, tests weakened to \"pass\" without fixing behavior, hard-coded environment assumptions, or leftover debug scaffolding/temporary artifacts.\n\nBe strict but precise: flag only discrete issues likely to break correctness, security, or reproducibility.";

pub const AUTO_EXEC_TIMEBOXED_GOAL_SUFFIX: &str = "Completion gate: do not end as success without proof.\n\nRequired proof: rerun the best available acceptance check for this goal (prefer `/tests/verify.sh`, else the narrowest relevant test), confirm exit 0, and confirm all required artifacts/paths/ports/output formats match the spec exactly.\n\nIf proof is not achievable, end as failed and report: the last check you ran, the current error/output, what changed, and the single next verification step.";
