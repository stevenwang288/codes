# 最高权限与长任务（排查笔记）

## 你说的“我已经给最高权限，但仍有限制”通常来自哪里
即使 `approval_policy = "never"`，仍可能出现“卡住/提示/要求确认”的来源：

1) **Sandbox 与审批组合**
- `sandbox_mode` 不同会限制写入、网络、进程等能力；TUI/CLI 两条入口都可能覆盖配置。

2) **confirm_guard（显式确认前缀）**
- 这是独立于 approvals 的二次保护：匹配到危险模式时，仍会要求“confirm 前缀”才执行。
- 关闭方式必须明确配置（否则看起来像“最高权限也不够丝滑”）。

3) **工具/子代理默认参数**
- 多代理/子代理会用“默认 args”启动（可能带 sandbox/approval 参数），导致与主进程不同步。

4) **注入（EnvironmentContext / 指令）造成的模型自我约束**
- 这不是硬限制，但模型可能因为“看见自己在受限环境/需要审批”的上下文而变保守。

---

## 目标：真正的“最高权限 / 最顺滑”

### A) 一次性命令（临时）
- CLI：`codes --dangerously-bypass-approvals-and-sandbox`（别名 `--yolo`）
  - 语义：无 sandbox、无审批提示（风险极高，只建议在你明确隔离/可信环境下用）

### B) 配置化（长期）
在 `~/.codes/config.toml` 内建议形成一个可切换 profile（后续计划集成进 `Ctrl+L` 面板与 `/settings`）：
- `sandbox_mode = "danger-full-access"`
- `approval_policy = "never"`
- `confirm_guard.patterns = []`（禁用 confirm_guard；否则仍会要求显式确认）

> 备注：这份 profile 的目标是“丝滑自动化”，不是默认值；默认仍应保留安全防线。

---

## 让它能跑 5–10 小时：工程化建议（先记录，逐步落地）
1) **把目标拆成可恢复的长 TODO**
- 任务拆分必须落地成可机器执行的 checklist（每条可验收、可回滚、可重试）。

2) **子代理隔离上下文 + 进度心跳**
- 主编排只消费“进度摘要”，并对“无增量 N 秒”做介入（暂停/重试/改拆分/换模型）。

3) **主代理无增量卡住监控（同等重要）**
- 不仅子代理会卡住，主流程也可能长时间等待（网络、模型端排队、工具挂起等）。
- 以“无增量（无新事件/无新输出/无 UI 状态变化）”作为统一判据：
  - 超过阈值 → UI 显示 `Stalled` + 桌面通知/声音提醒
  - 提供“不中断其它 TODO”的处置：取消/重试/换策略/改拆分/先做别的

3) **后台质量卫兵**
- 一个低优先级子代理持续做审计/测试，不阻塞主开发流；在合适时机集中反馈。

4) **回放与压缩策略**
- 控制上下文增长，确保长对话不会因为窗口溢出而失控；关键状态写入持久化文件供恢复。

---

## “质量档案/错误收录”怎么做才不污染上下文

结论：**不要放进注入**（也不要每轮塞进 AGENTS），而是做成**落盘的诊断档案**，需要时再摘要读取。

- 记录位置建议：`~/.codes/diagnostics/incidents.jsonl`
- 记录内容：错误类型、时间、触发入口、关键错误信息、（脱敏后的）环境摘要
- 调用方式：`/diagnostics` 或 `codes diagnostics` 输出摘要；需要时导出 Markdown 复盘
- 好处：既能长期积累“别再踩坑”的经验，又不会每轮注入导致上下文膨胀、输出变啰嗦
