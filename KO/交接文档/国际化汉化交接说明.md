# i18n/汉化交接说明（给后续 AI/开发者）

目标：**不破坏任何代码逻辑、不影响使用** 的前提下，把用户可见文案逐步抽离到 `code-i18n`，提供 `zh-CN` 翻译；缺翻译时自动回退英文。

本仓库日期：2026-01-23。

## 0. 底线与范围

- **底线**：只改“用户可见字符串”与其 i18n 调用方式，不改控制流/状态机/行为。
- **必须不翻译**：命令名、子命令、flag 名称、环境变量名、路径、URL、JSON/协议字段、代码片段、错误码、版本号/模型名/工具名。
- **回退策略**：`zh-CN` 缺 key → 回退 `en`；两者都缺 → 显示 key 本身（仅用于暴露缺口）。

文案风格：

- 默认 **只输出中文**。
- 可选：仅在 **TUI 且空间足够** 时做 `中文（English）`/`中文 / English` 的双语对照（降低学习成本）。

## 1. 当前 i18n 架构（已落地）

- crate：`code-rs/i18n`（crate 名 `code-i18n`）
  - 语言探测 + 语言包加载 + 简单插值：`code-rs/i18n/src/lib.rs:1`
  - 语言包（JSON、随二进制内置 `include_str!`）：
    - `code-rs/i18n/assets/en.json:1`
    - `code-rs/i18n/assets/zh-CN.json:1`
- API：
  - `tr_plain("key") -> String`
  - `tr("key", &[("name", value), ...]) -> String`

### 1.1 边用边收集“缺翻译 key”（已支持）

目的：你不需要“喊话/手工记录”，只要正常使用（例如用 `codes` 启动），当 `zh-CN` 缺 key 时会自动把缺口写入一个文件，便于后续化整为零补翻译。

- 开关：`CODE_I18N_COLLECT_MISSING=1`
- 输出文件：
  - 默认：`$CODE_HOME/i18n-missing.jsonl`（`codes` 会把 `CODE_HOME`/`CODEX_HOME` 指到仓库内 `.codes-home/`）
  - 可覆盖：`CODE_I18N_COLLECT_PATH=<path>`

记录格式：JSONL，每行一条，例如：`{"ts_ms":...,"app":"code","missing_in":"zh-CN","key":"tui.xxx","fallback_text":"..."}`。

## 2. 已经做了什么（代码层）

### 2.1 Workspace 依赖接入

- workspace 引入 `code-i18n`：`code-rs/Cargo.toml:20`
- CLI 依赖：`code-rs/cli/Cargo.toml:25`
- TUI 依赖：`code-rs/tui/Cargo.toml:39`

### 2.2 已接入的文案（示例范围，不是全量）

- CLI
  - 登录：`code-rs/cli/src/login.rs:13`
  - MCP：`code-rs/cli/src/mcp_cmd.rs:15`
  - bridge/resume：`code-rs/cli/src/main.rs:31`
- TUI
  - 问候占位符：`code-rs/tui/src/greeting.rs:16`
  - onboarding “Trust directory” 页面：`code-rs/tui/src/onboarding/trust_directory.rs:1`

### 2.3 启动入口（你约定的“汉化版启动方式”）

- Repo 根目录：`codes` / `codes.cmd`
- 它们会设置：
  - `CODE_HOME=$PWD/.codes-home`（把配置/状态落到仓库本地，避免污染全局）
  - `CODEX_LANG=zh-CN`（强制中文）
  - `CODE_AUTO_TRUST=1`（尽量避免交互式 trust 提示）

## 3. “如何快做”的工作法（给另一个 AI）

### 3.1 一条最短流水线（高效且不伤逻辑）

1) 用 `rg` 扫描硬编码用户可见英文：

   - CLI：优先找 `println!` / `eprintln!` / `bail!` / `anyhow!` / `.context("...")` / `.with_context(|| format!("..."))`
   - TUI：优先找 `Span::raw("...")` / `Line::from("...")` / `Paragraph::new("...")`

2) 每命中一条，按下面规则替换：

   - 纯静态字符串：
     - `"text"` → `tr_plain("some.key")`
   - 含变量（原本 `format!` / `{var}`）：
     - 把变量变成占位参数（不要拼接）：
       - `tr("some.key", &[("var", value)])`

3) 同步更新语言包：

   - `en.json` 必须新增同名 key，并保留原英文（作为基线）。
   - `zh-CN.json` 写自然中文（可以先覆盖高频路径）。

4) 只要不改逻辑、只改字符串，就能快速推进且风险极低。

### 3.2 Key 命名（够用就行，不要过度设计）

- 统一前缀：
  - CLI：`cli.*`
  - TUI：`tui.*`
- 推荐：`<area>.<topic>.<meaning>`
  - 例：`cli.login.success`、`tui.onboarding.trust.press_prefix`

## 4. Windows/子代理相关坑（需要提前知道）

### 4.1 子代理 worktree “Filename too long”

现象：写权限子代理创建 worktree 时，可能在 `codex-rs/**/snapshots/*.snap` 报 `Filename too long`。

处理：

- 已执行：`git config core.longpaths true`（仓库 + global）。
- 仍可能需要：Windows 系统层面开启 long paths（组策略/注册表）。
- 另外：尽量让工作目录更短（把仓库放更浅的路径），能显著降低碰到长路径。

### 4.2 bash/WSL

- `./build-fast.sh` 必须在 bash 环境跑。
- 建议在 Windows 下使用 Git for Windows 自带的 bash（`codes.cmd` 已尝试按此路径调用）。

## 5. 模型/子代理设置如何持久化（你要求只用 GPT-5.2-Codex）

你当前的 `codes` 启动方式会把 `CODE_HOME`/`CODEX_HOME` 指到仓库的 `.codes-home/`。

- 已在 `D:\OneDrive\steven\code\ai\12CLI\code-main\.codes-home/config.toml` 写入：
  - `[[subagents.commands]] name = "plan"|"solve"|"code"` 都固定 `agents = ["code-gpt-5.2-codex"]`

如果你不用 `codes`，而是用全局配置，则把相同配置写入：`~/.code/config.toml`。

附：当前仓库内已写入该配置（用于 `codes`）：`.codes-home/config.toml:1`

## 6. 交接给“做汉化的 AI”时的任务拆分（建议）

按模块并行推进（每块都是机械替换+加 key，速度快）：

- CLI：`code-rs/cli/src/**`
- TUI onboarding：`code-rs/tui/src/onboarding/**`
- TUI approval：`code-rs/tui/src/user_approval_widget.rs` + `code-rs/tui/src/bottom_pane/approval_modal_view.rs`
- TUI bottom pane：`code-rs/tui/src/bottom_pane/**`

每块提交前都保证：新增 key 同步写入 `en.json` 和 `zh-CN.json`。

## 7. 我后续负责的“检查工作”建议清单

- 检查有没有把命令/flag/env var 翻译掉。
- 检查有没有把字符串拼接改坏（尽量用 `tr("key", vars)`）。
- 检查 `en.json` 是否漏 key（漏了会让中文回退也失效）。
- 跑一次 `./build-fast.sh`（能跑 bash 的环境下）。
