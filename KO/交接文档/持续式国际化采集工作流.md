# 持续式国际化采集工作流（用着用着就把 i18n 做完）

目标：你不需要专门“喊话/集中翻译”。日常使用时自动收集缺口，空闲时再让 AI 统一翻译并回写。

## 1) 运行期：边用边收集

### 1.1 开关

已在本仓库 `codes`/`codes.cmd` 默认开启：

- `CODE_I18N_COLLECT_MISSING=1`

### 1.2 收集文件

默认输出：`$CODEX_HOME/i18n-missing.jsonl`

你用 `codes` 启动时，`CODE_HOME`/`CODEX_HOME` 指向仓库内 `.codes-home/`，所以通常文件路径是：

- `.codes-home/i18n-missing.jsonl`

如要改位置：

- `CODE_I18N_COLLECT_PATH=<path>`

### 1.3 什么时候会记一条？

当调用 `code-i18n` 的 `tr_plain/tr`：

- 当前语言是 `zh-CN`
- 且 `zh-CN.json` 缺 key

则记录一条缺口（并回退使用英文）。

## 2) 空闲时：生成任务包 → AI 翻译 → 回写

### 2.1 生成“待翻译任务包”（key → 英文）

```powershell
node KO/TOOLS/i18n-collector/cli.mjs extract `
  --log ".codes-home/i18n-missing.jsonl" `
  --en "code-rs/i18n/assets/en.json" `
  --out ".codes-home/i18n-todo.zh-CN.json"
```

### 2.2 让 AI 翻译（自动化）

直接一条命令自动翻译（使用 Code CLI；不会接管终端渲染）：

```powershell
node KO/TOOLS/i18n-collector/cli.mjs translate `
  --in ".codes-home/i18n-todo.zh-CN.json" `
  --out ".codes-home/i18n-zh-CN.patch.json" `
  --runner coder `
  --model code-gpt-5.2-codex `
  --style zh-only
```

可选：TUI 空间足够时双语对照：`--style bilingual-tui`。

### 2.3 回写到 `zh-CN.json`

```powershell
node KO/TOOLS/i18n-collector/cli.mjs apply `
  --in ".codes-home/i18n-zh-CN.patch.json" `
  --zh "code-rs/i18n/assets/zh-CN.json"
```

## 3) 多项目扩展

这个流程不要求 Rust：

- 任何 CLI/TUI 只要把缺口写成 JSONL（append），就能被 `KO/TOOLS/i18n-collector` 聚合。
- 你可以让不同项目把 `CODE_I18N_COLLECT_PATH` 指向不同文件，最后统一用 `extract/apply`。
