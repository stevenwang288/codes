# CODES PatchKit 开发交接与交付标准（中文）

> 目标：即使对话上下文丢失，任何后续 AI / 开发者也能按本文档继续推进，并且能稳定复用这套“采集 → 汉化 → 更新 → 回放补丁 → 编译 → 重启”的工作流。

## 0. 术语与边界

- **CODES**：我们在本机对 `code-main` 的本地发行/使用形态。要求：**与 Codex/Codex CLI 并行且互不污染**。
- **PatchKit**：本仓库内的“本地补丁包与工作流工具”，目录固定为：`tools/code-patchkit/`。
- **采集**：指“运行时记录缺翻译 key（i18n missing）”到 JSONL；不是静态扫描。
- **汉化**：只做 `zh-CN`，缺 key 回退英文；最终目标是尽量不回退。

### 底线（必须遵守）

1) 不改业务逻辑：只改用户可见字符串、i18n 调用、工作流脚本。
2) 不引入复杂的 feature flag：保持 KISS。
3) 所有本地增强必须收敛到 `tools/code-patchkit/`，避免散落。

## 1. 目录结构（统一入口）

所有本地增强都放在：`tools/code-patchkit/`

- `tools/code-patchkit/patchkit.ps1`
  - 单一入口命令（建议只记这一个）。
- `tools/code-patchkit/scripts/`
  - 可复用的子脚本（i18n 向导、应用补丁、build、start、watchdog 等）。
- `tools/code-patchkit/notify/`
  - Windows 通知/声音脚本。
- `tools/code-patchkit/patches/`
  - 可重复回放的补丁（`git apply`）。
- `tools/code-patchkit/patchkit.json.example`
  - PatchKit 可选配置示例（上游 remote/branch、home 路径等）。

## 2. CODES 的“完全独立路径”规范

核心原则：**所有状态/配置/历史/采集日志，必须落在仓库内的 `./.codes-home/`**。

- `codes` / `codes.cmd` 启动时设置：
  - `CODE_HOME=./.codes-home`
  - `CODEX_HOME=./.codes-home`（兼容旧路径读取）

为什么要同时设置？

- 项目中仍存在 `CODEX_HOME` 的兼容读取逻辑；如果只设置一个，容易出现“读 A 写 B”。

## 3. i18n 采集机制（运行时）

### 3.1 采集触发条件

- 当前语言为 `zh-CN`
- 调用了 `code-i18n` 的 `tr_plain` / `tr`
- `zh-CN.json` 缺该 key

满足上述条件时，会追加一行 JSON 到：

- 默认：`./.codes-home/i18n-missing.jsonl`
 - 默认：`$CODE_HOME/patchkit/i18n-missing.jsonl`

### 3.2 JSONL 记录字段（最小集合）

- `ts_ms`：时间戳（毫秒）
- `app`：进程名（用于多项目汇总）
- `missing_in`：缺失在哪个语言包（例如 `zh-CN`）
- `key`：i18n key
- `fallback_text`：可选（便于没有 en.json 时仍可翻译）

## 4. i18n 处理工具（离线/可复用）

工具入口：`KO/TOOLS/i18n-collector/cli.mjs`

### 4.1 常用命令

- `stats`：统计缺口（支持按类型 CLI/TUI/站点聚合，支持 rules 覆盖）
- `sync`：一键闭环（extract → translate → apply），支持 `--once`/`--watch`

> 注意：这套工具设计为“多项目可复用”，只依赖 JSONL 格式。

## 5. PatchKit 工作流（向导式、惰性执行）

### 5.1 “启动时注入，但不自动执行”

我们采用：

- **注入**：启动时只把入口命令准备好（`patchkit.ps1`、以及必要的 config hook）。
- **惰性执行**：只有用户显式运行某个命令，才会执行 `git fetch/pull`、翻译、编译等动作。

### 5.2 入口命令（建议用户只记一个）

```powershell
pwsh -ExecutionPolicy Bypass -File "./tools/code-patchkit/patchkit.ps1" help
```

典型：

- 状态总览（只读）：

```powershell
pwsh -ExecutionPolicy Bypass -File "./tools/code-patchkit/patchkit.ps1" status -Fetch
```

- 向导式更新（可选 pull/apply/i18n/build/restart）：

```powershell
pwsh -ExecutionPolicy Bypass -File "./tools/code-patchkit/patchkit.ps1" update -Fetch
```

## 6. 交付标准（Definition of Done）

### 6.1 收集功能完成标准

1) TUI/CLI 中的关键“介绍/命令提示/面板说明”都走 i18n key，不允许硬编码英文。
2) 当 `zh-CN` 缺 key 时，能稳定写入 `./.codes-home/i18n-missing.jsonl`。
3) `KO/TOOLS/i18n-collector stats` 能正确统计 pending。

### 6.2 向导完成标准

1) 每一步都可单独执行（stats/sync/build/restart）。
2) 每一步结束都会提示“是否继续下一步”。
3) 默认不做网络/编译（除非用户明确选择）。

### 6.3 Patch 回放标准

1) 所有本地改动都能通过 `tools/code-patchkit/patches/*.patch` 回放。
2) `apply-patches.ps1` 在“已应用”时会自动跳过，避免重复 apply。

## 7. 常见问题

### 7.1 为什么有时看不到 i18n-missing.jsonl？

因为没有触发“缺 key”路径：

- `zh-CN.json` key 已齐全时，不会写缺口。

### 7.2 为什么要用数字/中文 slash 命令？

目标是降低英文负担：

- `/1` `/2` … 比 `/settings` 更容易记。
- 同时仍保留英文兼容（旧习惯不被破坏）。
